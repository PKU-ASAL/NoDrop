#include <elf.h>
#include <link.h>
#include <assert.h>

#include "reloc.h"

static ElfW(Addr) __used   _reloc_start(void *arg);
static ElfW(Addr) __inline elf_load_address();
static ElfW(Addr) __inline elf_dynamic_address();
static void       __inline elf_get_dynamic_infomation(struct reloc_struct *l);
static void       __inline elf_dynamic_do_Rel(struct reloc_struct *map, ElfW(Addr) reladdr, ElfW(Addr) relsize,
		                                        __typeof (((ElfW(Dyn) *) 0)->d_un.d_val) nrelative,
		                                        int lazy, int skip_ifunc);
static void       __inline elf_machine_rela(struct reloc_struct *map, const ElfW(Rela) *reloc,
                                            const ElfW(Sym) *sym, void *const reloc_addr_arg, int skip_ifunc);
static void       __inline elf_machine_rela_relative(ElfW(Addr) l_addr, const ElfW(Rela) *reloc, void *const reloc_addr_arg);

#ifndef NULL
#define NULL ((void *)0)
#endif // NULL

#define ELFW(type)	_ElfW (ELF, __ELF_NATIVE_CLASS, type)

#ifdef START_ENTRY
START_ENTRY
#endif // START_ENTRY


static ElfW(Addr) __used
_reloc_start(void *arg) {
    int i;
    struct reloc_struct l;

    // init dyn_info
    for (i = 0;
         i < sizeof(l.l_info) / sizeof(l.l_info[0]);
         i++) {
        l.l_info[i] = 0;
    }

    l.l_addr = elf_load_address();
    l.l_ld   = (void *) l.l_addr + elf_dynamic_address();

    elf_get_dynamic_infomation(&l);

    if (l.l_addr || !l.l_info[VALIDX(DT_GNU_PRELINKED)]) {
        /* Relocate ourselves so we can do normal function calls and data access using the global offset table.  */
        ELF_DYNAMIC_RELOCATE (&l, 0, 0, 0);
    }

    extern int main(void);
    return (ElfW(Addr))main;
}

static ElfW(Addr) __inline
elf_load_address() {
    extern ElfW(Dyn) _DYNAMIC[] __hidden;
    return (ElfW(Addr)) &_DYNAMIC - elf_dynamic_address();
}

static ElfW(Addr) __inline
elf_dynamic_address() {
    // _GLOBAL_OFFSET_TABLE is a hidden symbol generated by linker during static linking, and
    // it indicates the location of .got.plt section. The first element is filled with the address of .dynamic section by linker
    extern const ElfW(Addr) _GLOBAL_OFFSET_TABLE_[] __hidden;
    return _GLOBAL_OFFSET_TABLE_[0];
}

static void __inline
elf_get_dynamic_infomation(struct reloc_struct *l) {
    ElfW(Dyn) *dyn;
    ElfW(Dyn) **info;

    if (l->l_ld == NULL)
        return;

    for (dyn = l->l_ld, info = l->l_info; dyn->d_tag != DT_NULL; ++dyn) {
        if ((ElfW(Xword)) dyn->d_tag < DT_NUM)
            info[dyn->d_tag] = dyn;
        else if (dyn->d_tag >= DT_LOPROC && dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)
            info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;
        else if ((ElfW(Xword)) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
            info[VERSYMIDX (dyn->d_tag)] = dyn;
        else if ((ElfW(Xword)) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
            info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM] = dyn;
        else if ((ElfW(Xword)) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
            info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;
        else if ((ElfW(Xword)) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
            info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;
    }

# define ADJUST_DYN_INFO(tag) do{if (info[tag] != NULL)info[tag]->d_un.d_ptr += l->l_addr;} while(0)
    ADJUST_DYN_INFO (DT_HASH);
    ADJUST_DYN_INFO (DT_PLTGOT);
    ADJUST_DYN_INFO (DT_STRTAB);
    ADJUST_DYN_INFO (DT_SYMTAB);
    ADJUST_DYN_INFO (DT_RELA);
    ADJUST_DYN_INFO (DT_REL);
    ADJUST_DYN_INFO (DT_JMPREL);
    ADJUST_DYN_INFO (VERSYMIDX (DT_VERSYM));
    ADJUST_DYN_INFO (DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM);
# undef ADJUST_DYN_INFO
}

static void __inline
elf_dynamic_do_Rel (struct reloc_struct *map,
		    ElfW(Addr) reladdr, ElfW(Addr) relsize,
		    __typeof (((ElfW(Dyn) *) 0)->d_un.d_val) nrelative,
		    int lazy, int skip_ifunc) {
    const ElfW(Rel) *r = (const void *) reladdr;
    const ElfW(Rel) *end = (const void *) (reladdr + relsize);
    ElfW(Addr) l_addr = map->l_addr;

    const ElfW(Sym) *const symtab = (const void *) D_PTR(map, l_info[DT_SYMTAB]);
    const ElfW(Rel) *relative = r;
    r += nrelative;

    for (; relative < r; ++relative)
        elf_machine_rel_relative(l_addr, relative, (void *) (l_addr + relative->r_offset));

    // assert (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL);

    const ElfW(Half) *const version = (const void *) D_PTR(map, l_info[VERSYMIDX (DT_VERSYM)]);
    for (; r < end; ++r) {
        ElfW(Half) ndx = version[ELFW(R_SYM) (r->r_info)] & 0x7fff;
        elf_machine_rel (map, r, &symtab[ELFW(R_SYM) (r->r_info)],
                (void *) (l_addr + r->r_offset), skip_ifunc);
    }
}

static void __inline
elf_machine_rela (struct reloc_struct *map, const ElfW(Rela) *reloc,
		  const ElfW(Sym) *sym, void *const reloc_addr_arg, int skip_ifunc) {
    ElfW(Addr) *const reloc_addr = reloc_addr_arg;
    const unsigned long int r_type = ELFW(R_TYPE) (reloc->r_info);

    if (__glibc_unlikely (r_type == R_X86_64_NONE))
        return;

    struct reloc_struct *sym_map = map;
    ElfW(Addr) value = (sym == NULL ? 0 : (ElfW(Addr)) sym_map->l_addr + sym->st_value);

    if (sym != NULL && 
            __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC, 0) &&
            __builtin_expect (sym->st_shndx != SHN_UNDEF, 1) &&
            __builtin_expect (!skip_ifunc, 1)) {
        value = ((ElfW(Addr) (*) (void)) value) ();
    }

    switch (r_type) {
		case R_X86_64_GLOB_DAT:
		case R_X86_64_JUMP_SLOT:
		  *reloc_addr = value + reloc->r_addend;
		  break;
	}
}

static void __inline
elf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
			   void *const reloc_addr_arg) {
    ElfW(Addr) *const reloc_addr = reloc_addr_arg;
    // assert(ELFW(R_TYPE) (reloc->r_info) == R_X86_64_RELATIVE);
    *reloc_addr = l_addr + reloc->r_addend;
}